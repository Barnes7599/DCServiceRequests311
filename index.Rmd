---
output:
  html_document:
    toc: true
    toc_float: true
    theme: "yeti"
    code_folding: hide
---

![](https://github.com/Barnes7599/DCServiceRequests311/blob/main/311.png?raw=true)
Disclaimer: This project is not affiliated, associated, authorized, endorsed by, or in any way officially connected with DC 311, or any of its subsidiaries or its affiliates. The official DC 311 website can be found [here](https://311.dc.gov/citizen/home)

---

### DC Service Calls (311) Data Analysis and Visualizations
This project breaks down DC Service Calls (311) in 2022. This is an ongoing project that I will utilize to learn more about R and Data Visualizations. Please follow along or check back from time to time to see the progress.

The data was extracted from the Open Data DC website. There is a treasure trove of data that you can shift through to use for your own project or download the data [here](https://opendata.dc.gov/datasets/311-city-service-requests-in-2022/explore?location=39.971127%2C-78.566945%2C8.99&showTable=true) if you want to follow along.

311 City Service Requests are made directly on the official DC 311 website where residents can submit a request, check the status explore, maps, find resources for residents, businesses and visitors. The data used in this project is provided by the Office of Unified Communications, which collects detailed information on 311 Service calls. The data dictionary can be found [here](https://opendata.dc.gov/datasets/DCGIS::311-city-service-requests-in-2022/about)

This is a great data set that you can use to better your data analysis and visualization skills as it contains 25 attributes that make up the data set. You can explore service order dates tied to request resolution to mapping out where the Service Calls are located using Latitude and Longitude coordinates the analysis that can be done on this data set is endless.

## Lets get started...


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  cache = TRUE,
  fig.align = "center",
  tidy = "formatR"
)

unlink("index.cache", recursive = TRUE)
```


```{css headings, echo = FALSE}

p {
color: black;
margin: 30px 0 20px 0;
}

td {
    padding: 3px 10px 3px 10px;
    text-align: center;
}

table
{ 
    margin-left: auto;
    margin-right: auto;
    margin-top:80px;
    margin-bottom:100px;
}

h1, h2{
  margin-top:30px;
  margin-bottom:20px;
}

h3{
  margin-top:50px;
  margin-bottom:20px;
}

h4{
  margin-top:30px;
  margin-bottom:5px;
}

H5{
    text-align: center;
    color: gray;
    font-size:2em;
}

img {
    max-width: 100%;
    display: block;
    margin-right: auto;
    margin-left: auto;
    margin-top: auto;
    margin-bottom: auto;
}

pre {
  overflow-x: auto;
}

pre code {
   display: block; 
   padding: 0.5em;
   margin-bottom:10px;
}


code {
  font-size: 100%;
  border: 10px solid light gray;
  margin-bottom: 2px;
}

code[class] {
  background-color: light gray,
  margin-bottom; 15px;
}

.footer {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    text-align: right;
}


```


<div class="footer">
  <p> barnes7599@gmail.com |  Updated  <script> document.write(new Date().toLocaleDateString()); </script> </p>
</div>
<style type="text/css">
h4.date {
  text-align: right;
}
</style>


### Load Libraries

Load packages - you may need to install packages using the install.packages() function. Make sure you put the package name in quotes like install.packages("tidyverse"), you will only have to do this once. 

```{r, echo = TRUE}
library(tidyverse)
library(lubridate)
library(readxl)
library(showtext)
library(ggtext)
library(glue)
library(patchwork)
library(gt)

```

---

### Load the data

Data set is located at:[Dataset](https://opendata.dc.gov/datasets/311-city-service-requests-in-2022/explore?location=39.982830%2C-78.566945%2C8.99&showTable=true) <br>
Dataset about page located here:[About](https://opendata.dc.gov/datasets/DCGIS::311-city-service-requests-in-2022/about)

I typically use the [janitor](https://github.com/sfirke/janitor) package whenever I read in a data set. it cleans up the column headings by making them all lower case and placing an underscore between spaces. So let's read in the data and look at the top 6 rows of the data frame.

```{r, echo= TRUE}

service_calls_2022 <- read_csv("https://raw.githubusercontent.com/Barnes7599/DCServiceRequests311/main/DC_service_calls.csv") %>%
  janitor::clean_names()

head(service_calls_2022)
```

---

### Add design elements

I typically will add in design elements upfront so that I know what fonts and colors I will be using in the visualizations. We will use the [showtext](https://github.com/yixuan/showtext) package to read in goggle fonts.

```{r, echo=TRUE}

# Assign color variables
col1 <- "#E1DABF"
col2 <- "#3C6075"

# Adding Google Fonts
font_add_google(family = "patua-one", "Patua One")
font_add_google(family = "montserrat", "Montserrat")

# function used to tell the code below use the above fonts
showtext_auto()
```

---

### Add date variables

At this point I believe that I want to do a heatmap type visualizations so that we can capture the time and day service calls are expected more often. In order to do that we need to use the [lubridate](https://lubridate.tidyverse.org/) package which should help us wrangle the date time groups in the data set. 


```{r, echo=TRUE}

df_2022 <- service_calls_2022 %>%
  # I want to scope down the dataframe so I will only select columns that I am interested in for the heatmap
  select(organizationacronym, servicecodedescription, serviceorderdate, serviceduedate, resolutiondate,
    # Rename the column serviceorderstatus to status
    status = serviceorderstatus
  ) %>%
  # Need to fix an error in the dataset
  mutate(
    status = case_when(
      status == "In Progress" ~ "In-Progress",
      TRUE ~ status
    ),
    # Converting to date and time data type
    serviceorderdate = ymd_hms(serviceorderdate),
    serviceduedate = ymd_hms(serviceduedate),
    resolutiondate = ymd_hms(resolutiondate),
    # Need to determine the difference in days between the service order data and when the service request was resolved
    daystoresolve = as.double(difftime(
      resolutiondate,
      serviceorderdate
    ),
    units = "days"
    ),
    # Need to determine the difference in days between the service due date and when it was resolved to see later if there is a coorelation between the service request and the time it takes to resolve the service ticket
    dayspastdue = as.double(difftime(
      resolutiondate,
      serviceduedate
    ),
    units = "days"
    ),
    # Capture the abbreviation for each day in the week
    dayorderdate = wday(serviceorderdate, label = TRUE, abbr = TRUE),
    # Pulling out the hour in the time group
    hourorderdate = hour(serviceorderdate)
  )
```

---

## Heatmaps

Why heatmaps? One because they are fun...and humans have limitations to the amount of information that we can process and pay attention to at the same time. For example, it is challenging for anyone to perform mental math, while at the same time interpreting textual information. However, humans are very efficient at identifying differences in certain types of visual characteristics, such as color, size, shape and orientation. By definition, heatmap visualization or heatmap data visualization is a method of graphically representing numerical data where the value of each data point is indicated using colors. 

Our brains process sensory input quickly and automatically, before we are paying conscious attention. This type of processing is called pre-attentive processing.<sup>[1](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5313506/)</sup> For visual processing there are certain attributes that the human visual system processes in this fast-automatic way. These attributes are known as pre-attentive attributes.<sup>[2](https://www.perceptualedge.com/articles/ie/visual_perception.pdf)</sup> We notice and process these attributes before we concentrate and focus on them. When pre-attentive attributes are used strategically in visualizations, viewers process that information very quickly. Pre-attentive attributes help avoid the mind-numbing work of concentrating and consciously interpreting information, which most people either do not want to do or have no time to do. 

Heatmaps are crucial to visualize behavior data so that decision makers can identify the potential problem areas, best practices or visitor interaction

---

### Heatmap 1

#### Building the Heatmap

```{r, echo=TRUE, fig.width=10}


# Creating helper functions so that I can use the glue() package to capture the max and min dates when the data set is updated.

max_date_2022 <- service_calls_2022 %>%
  select(serviceorderdate) %>%
  separate(col = serviceorderdate, into = c("date", "time"), sep = " ") %>%
  select(-time) %>%
  mutate(date = ymd(date)) %>%
  arrange(desc(date)) %>%
  head(1) %>%
  mutate(date = as.character(date))

min_date_2022 <- service_calls_2022 %>%
  select(serviceorderdate) %>%
  separate(col = serviceorderdate, into = c("date", "time"), sep = " ") %>%
  select(-time) %>%
  mutate(date = ymd(date)) %>%
  head(1) %>%
  mutate(date = as.character(date))

caption <- glue("Data source: https://opendata.dc.gov/ | Dates: ({min_date_2022} to {max_date_2022})")

heatmap_day_hour_2022 <- df_2022 %>%
  select(dayorderdate, hourorderdate) %>%
  mutate(dayorderdate = fct_rev(dayorderdate)) %>%
  group_by(dayorderdate, hourorderdate) %>%
  summarise(N = n(), .groups = "drop") %>%
  as_tibble() %>%
  ggplot(aes(hourorderdate, dayorderdate, fill = N)) +
  geom_tile(color = "white", na.rm = TRUE) +
  scale_fill_gradient(low = col1, high = col2) +
  guides(fill = guide_legend(title = "Number of Service Calls")) +
  labs(
    title = "DC Service Calls (311) in 2022 by Day and Hour",
    caption = caption,
    y = NULL,
    x = NULL
  ) +
  theme_classic() +
  theme(
    text = element_text(
      family = "montserrat",
      size = 16
    ),
    plot.title = element_markdown(
      family = "patua-one",
      size = 20,
      margin = margin(b = 5)
    ),
    plot.subtitle = element_markdown(margin = margin(b = 10)),
    plot.title.position = "plot",
    plot.caption.position = "plot",
    plot.caption = element_text(
      hjust = 0,
      margin = margin(t = 15)
    ),
    axis.line.y = element_blank(),
    axis.text = element_text(size = 14),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.ticks = element_blank(),
    # axis.line.x = element_line(),
    # axis.line.x.bottom = element_blank(),
    legend.position = "bottom",
    plot.margin = margin(t = 10, r = 20, b = 10, l = 20)
  )

heatmap_day_hour_2022

```

As you can see the heatmap shows the day of week and the time of day when the service center receives the majority of calls. The blue represents the busiest times for the call center. A manger could use this to help shape their staffing requirements at the call center. A cool comparison could be if we capture the data from 2019 a year prior to the pandemic with an assumption that the distribution of day and time would be different. This may help gain some insight on whether or not remote work is contributing to an increase in calls during the day since there is an assumption that more people are working from home now compared to 2019. We will save that for another project! 

---

### Heatmap 2
I think it would be interesting to explore the type of service requested by hour of the day. This could be beneficial for the departments to know when their service is typically being requested throughout the day. I need to create some helper functions so that I can include some dynamic titles or 

```{r, fig.height=12, fig.width=10, echo=TRUE}

# Creating helper functions so that I can use the glue() package to capture the the top 3 services requested
topservicereq <- df_2022 %>%
  select(servicecode = servicecodedescription) %>%
  group_by(servicecode) %>%
  summarise(N = n(), .groups = "drop") %>%
  top_n(3) %>%
  pull(servicecode)

req1 <- topservicereq[[1]]
req2 <- topservicereq[[2]]
req3 <- topservicereq[[3]]


# Creating the heatmap
heatmap_description <- df_2022 %>%
  select(servicecode = servicecodedescription) %>%
  group_by(servicecode) %>%
  summarise(N = n(), .groups = "drop") %>%
  # After grouping the service codes and counting the calls for a service we simply show only those service calls
  # that occurred greater than 100 times
  filter(N > 100) %>%
  select(servicecode) %>%
  left_join(df_2022 %>%
    select(
      servicecode = servicecodedescription,
      hourorderdate
    ) %>%
    group_by(servicecode, hourorderdate) %>%
    summarise(N = n(), .groups = "drop"),
  by = "servicecode"
  ) %>%
  mutate(servicecode = as_factor(servicecode) %>% fct_reorder(N)) %>%
  ggplot(aes(hourorderdate, servicecode, fill = N)) +
  geom_tile(color = "white", na.rm = TRUE) +
  scale_fill_gradient(low = col1, high = col2) +
  guides(fill = guide_legend(title = "Number of Service Calls")) +
  labs(
    title = "DC Service Calls (311) 2022 by Service Description",
    subtitle = glue("Top 3 services requested: {req1}, {req2}, and {req3}"),
    caption = caption,
    y = NULL,
    x = NULL
  ) +
  theme_classic() +
  theme(
    text = element_text(
      family = "montserrat",
      size = 16
    ),
    plot.title = element_text(
      family = "patua-one",
      size = 20,
      margin = margin(b = 5)
    ),
    plot.subtitle = element_text(margin = margin(b = 20)),
    plot.title.position = "plot",
    plot.caption.position = "plot",
    plot.caption = element_text(
      hjust = 0,
      margin = margin(t = 15)
    ),
    axis.line.y = element_blank(),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text = element_text(size = 14),
    axis.ticks = element_blank(),
    # axis.line.x = element_line(),
    # axis.line.x.bottom = element_blank(),
    legend.position = "bottom",
    plot.margin = margin(t = 10, r = 20, b = 10, l = 20)
  )

heatmap_description
```

---

Next, let's take a look at the status of service requests so far in 2022. 

## Status of service requests

```{r, echo=TRUE,fig.width=10,fig.height=5}

pcttotalclosed <- df_2022 %>%
  count(status) %>%
  mutate(status = status %>% as_factor() %>% fct_reorder(n)) %>%
  arrange(desc(n)) %>%
  mutate(pcttotal = n / sum(n)) %>%
  filter(status == "Closed") %>%
  pull()

pcttotalclosed <- as.double(round(pcttotalclosed, digits = 3)) %>% scales::percent()

status_bar <- df_2022 %>%
  count(status) %>%
  mutate(status = status %>% as_factor() %>% fct_reorder(n)) %>%
  filter(status != "Closed", status != "Closed (Duplicate)") %>%
  arrange(desc(n)) %>%
  ggplot(aes(n, status, label = n)) +
  geom_col(fill = col2) +
  # geom_text(label = n) +
  geom_hline(yintercept = 0) +
  labs(
    title = glue("{pcttotalclosed} of DC Service Calls (311) have been closed that were opened since 1 Jan 2022"),
    subtitle = glue("of those that are not closed the majority are either Open or In-Progress"),
    caption = caption,
    y = NULL,
    x = "Number of service calls"
  ) +
  theme_classic() +
  theme(
    text = element_text(
      family = "montserrat",
      size = 16
    ),
    plot.title = element_markdown(
      family = "patua-one",
      size = 20,
      margin = margin(b = 5)
    ),
    plot.subtitle = element_markdown(margin = margin(b = 10)),
    plot.title.position = "plot",
    plot.caption.position = "plot",
    plot.caption = element_text(
      hjust = 0,
      margin = margin(t = 15)
    ),
    axis.line.y = element_blank(),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text = element_text(size = 14),
    axis.ticks = element_blank(),
    # axis.line.x = element_line(),
    # axis.line.x.bottom = element_blank(),
    legend.position = "bottom",
    plot.margin = margin(t = 10, r = 20, b = 10, l = 20)
  )

status_bar
```
This seems ok, but do we really care about the service calls that have been Canceled, Closed (Transferred) or Open (Duplicates)? I do not believe it gives us any information that we can make possible decisions on. I think making a stacked bar chart of the tickets that are Open or In-Progress may be a neat may to visualizes the information so that when we can measure progress on closing requests. Plus, I think it would be fun if we made the title and subtitle dynamic by including the number of service calls and a breakdown of what percent is Open vs In-Progress. 

---

### Open and In-Progress

```{r, echo=TRUE, fig.width=10,fig.height=3}

open_inprogress <- df_2022 %>%
  filter(status %in% c("Open", "In-Progress")) %>%
  count() %>%
  pull()


open <- df_2022 %>%
  filter(status %in% c("Open", "In-Progress")) %>%
  count(status) %>%
  # We need to add a column to show the proportion
  mutate(prop = n / sum(n)) %>%
  select(status, prop) %>%
  filter(status == "Open") %>%
  pull() %>%
  scales::percent()


in_progress <- df_2022 %>%
  filter(status %in% c("Open", "In-Progress")) %>%
  count(status) %>%
  # We need to add a column to show the proportion
  mutate(prop = n / sum(n)) %>%
  select(status, prop) %>%
  filter(status == "In-Progress") %>%
  pull() %>%
  scales::percent()

num_service_calls_7_days_ago <- df_2022 %>%
  filter(serviceorderdate <= Sys.Date() - 7, status %in% c("Open", "In-Progress")) %>%
  count() %>%
  pull()

num_service_calls_7_days_ago_df <- df_2022 %>%
  filter(serviceorderdate <= Sys.Date() - 7, status %in% c("Open", "In-Progress")) %>%
  count()


status_bar_count <- df_2022 %>%
  filter(status %in% c("Open", "In-Progress")) %>%
  count(status) %>%
  # We need to add a column to show the proportion
  mutate(prop = n / sum(n)) %>%
  mutate(status = status %>% as_factor() %>% fct_reorder(n)) %>%
  arrange(desc(n)) %>%
  ggplot(aes(
    x = 1, y = n,
    fill = status
  )) +
  geom_bar(stat = "identity") +
  coord_flip() +
  geom_hline(yintercept = 0) +
  # geom_hline(yintercept = num_service_calls_7_days_ago) +
  scale_fill_manual(
    values = c(col1, col2),
    breaks = c("Open", "In-Progress")
  ) +
  labs(
    title = glue("There are {open_inprogress} DC Service Calls (311) that remain Open or In-progess since 1 Jan 2022"),
    subtitle = glue("of which {open} are Open and {in_progress} are In-Progess"),
    caption = caption,
    y = NULL,
    x = "Number of service calls"
  ) +
  theme_classic() +
  theme(
    text = element_text(
      family = "montserrat",
      size = 16
    ),
    plot.title = element_textbox_simple(
      family = "patua-one",
      size = 20,
      margin = margin(b = 5)
    ),
    plot.subtitle = element_markdown(margin = margin(b = 20)),
    plot.title.position = "plot",
    plot.caption.position = "plot",
    plot.caption = element_text(
      hjust = 0,
      margin = margin(t = 15)
    ),
    axis.line.y = element_blank(),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title = element_blank(),
    axis.text.y = element_blank(),
    # axis.text.x = element_blank(),
    # axis.line.x = element_blank(),
    axis.text = element_text(size = 14),
    axis.ticks = element_blank(),
    # axis.line.x = element_line(),
    # axis.line.x.bottom = element_blank(),
    legend.position = "top",
    legend.margin = margin(t = 10),
    plot.margin = margin(t = 10, r = 20, b = 10, l = 20)
  )

status_bar_count
```

This looks better and one can easy see were we are in terms of servicing the open requests. Lets dive into Open and In-Progress on their own. I think it would be beneficial to measure progess against how many Open or In-Progress tickets aganist 7-days ago. By using the glue() package and some helper code we can easily show whether or not the current count of service requests is more or less than 7-days ago. We can even play with coloring the Title some. 

---

### Open Service Requests

```{r, echo=TRUE, fig.width=10,fig.height=3}

count_open_now <- df_2022 %>%
  filter(status %in% c("Open")) %>%
  count() %>%
  pull()

count_open_7 <- df_2022 %>%
  filter(serviceorderdate <= Sys.Date() - 7, status %in% c("Open")) %>%
  count() %>%
  pull()

open_diff <- count_open_now - count_open_7

open_diff_text <- case_when(
  count_open_now > count_open_7 ~ "increase",
  count_open_now < count_open_7 ~ "decrease",
  TRUE ~ "same"
)


open_requests <- df_2022 %>%
  filter(status %in% c("Open")) %>%
  count() %>%
  ggplot(aes(x = 1, y = n)) +
  geom_bar(
    stat = "identity",
    fill = col1,
    show.legend = FALSE
  ) +
  coord_flip() +
  geom_hline(yintercept = 0) +
  geom_hline(yintercept = count_open_7) +
  annotate("text",
    x = 1,
    y = count_open_7 - 50,
    hjust = 1,
    color = col2,
    size = 5,
    label = glue("{count_open_7}\n7-days ago")
  ) +
  labs(
    title = glue("There are {count_open_now} DC Service Calls (311) that remain <span style='color: #E1DABF'>Open</span> since 1 Jan 2022"),
    subtitle = glue("That is an {open_diff_text} of {open_diff} from 7-days ago"),
    caption = caption,
    y = NULL,
    x = "Number of service calls"
  ) +
  theme_classic() +
  theme(
    text = element_text(
      family = "montserrat",
      size = 16
    ),
    plot.title = element_textbox_simple(
      family = "patua-one",
      size = 20,
      margin = margin(b = 5)
    ),
    plot.subtitle = element_markdown(margin = margin(b = 20)),
    plot.title.position = "plot",
    plot.caption.position = "plot",
    plot.caption = element_text(
      hjust = 0,
      margin = margin(t = 15)
    ),
    axis.line.y = element_blank(),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title = element_blank(),
    axis.text.y = element_blank(),
    # axis.text.x = element_blank(),
    # axis.line.x = element_blank(),
    axis.text = element_text(size = 14),
    axis.ticks = element_blank(),
    # axis.line.x = element_line(),
    # axis.line.x.bottom = element_blank(),
    legend.position = "top",
    legend.margin = margin(t = 10, b = -10),
    plot.margin = margin(t = 10, r = 20, b = 10, l = 20)
  )

open_requests
```

---

### In-Progress Service Requests


```{r, echo=TRUE, fig.width=10,fig.height=3}

count_inprogress_now <- df_2022 %>%
  filter(status %in% c("In-Progress")) %>%
  count() %>%
  pull()

count_inprogress_7 <- df_2022 %>%
  filter(serviceorderdate <= Sys.Date() - 7, status %in% c("In-Progress")) %>%
  count() %>%
  pull()

inprogress_diff <- count_inprogress_now - count_inprogress_7

inprogress_diff_text <- case_when(
  count_inprogress_now > count_inprogress_7 ~ "increase",
  count_inprogress_now < count_inprogress_7 ~ "decrease",
  TRUE ~ "same"
)

inprogress_requests <- df_2022 %>%
  filter(status %in% c("In-Progress")) %>%
  count() %>%
  ggplot(aes(x = 1, y = n)) +
  geom_bar(
    stat = "identity",
    fill = col2,
    show.legend = FALSE
  ) +
  coord_flip() +
  geom_hline(yintercept = 0) +
  geom_hline(yintercept = count_inprogress_7) +
  annotate("text",
    x = 1,
    y = count_inprogress_7 - 50,
    hjust = 1,
    color = col1,
    size = 5,
    label = glue("{count_inprogress_7}\n7-days ago")
  ) +
  labs(
    title = glue("{count_inprogress_now} DC Service Calls (311) remain <span style='color: #3C6075'>In-Progress</span> since 1 Jan 2022"),
    subtitle = glue("That is an {inprogress_diff_text} of {inprogress_diff} from 7-days ago"),
    caption = caption,
    y = NULL,
    x = "Number of service calls"
  ) +
  theme_classic() +
  theme(
    text = element_text(
      family = "montserrat",
      size = 16
    ),
    plot.title = element_textbox_simple(
      family = "patua-one",
      size = 20,
      margin = margin(b = 5)
    ),
    plot.subtitle = element_markdown(margin = margin(b = 20)),
    plot.title.position = "plot",
    plot.caption.position = "plot",
    plot.caption = element_text(
      hjust = 0,
      margin = margin(t = 15)
    ),
    axis.line.y = element_blank(),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title = element_blank(),
    axis.text.y = element_blank(),
    # axis.text.x = element_blank(),
    # axis.line.x = element_blank(),
    axis.text = element_text(size = 14),
    axis.ticks = element_blank(),
    # axis.line.x = element_line(),
    # axis.line.x.bottom = element_blank(),
    legend.position = "top",
    legend.margin = margin(t = 10, b = -10),
    plot.margin = margin(t = 10, r = 20, b = 10, l = 20)
  )

inprogress_requests

```

Now let's focus on if service requests are Open or In-Progress are any of them past due? We can capture the average days past due by grouping the service code description and summarizing the data by the mean days to resolve and mean days past due (days to resolve and days past due where columns we added when we wrangled the data frame)

---

### Days Service Request Past Due

```{r, echo=TRUE, fig.width=10, fig.height=5}

percent_on_time <- df_2022 %>%
  select(servicecodedescription, status, daystoresolve, dayspastdue) %>%
  filter(status == "Closed") %>%
  drop_na() %>%
  mutate(countpastdue = if_else(dayspastdue > 0, "Past Due", "On Time")) %>%
  count(countpastdue) %>%
  mutate(percent_of_total = n / sum(n)) %>%
  filter(countpastdue == "On Time") %>%
  pull()

percent_on_time <- as.double(round(percent_on_time, digits = 3)) %>% scales::percent()


dayspastdue <- df_2022 %>%
  select(servicecodedescription, status, daystoresolve, dayspastdue) %>%
  filter(status == "Closed") %>%
  # filter(servicecodedescription %in% c("Trash Collection - Missed", "Illegal Dumping", "Bulk Collection")) %>%
  drop_na() %>%
  mutate(countpastdue = if_else(dayspastdue > 0, "Past Due", "On Time")) %>%
  filter(countpastdue == "Past Due") %>%
  select(servicecodedescription, dayspastdue) %>%
  group_by(servicecodedescription) %>%
  summarise(
    avgpastdue = mean(dayspastdue),
    .groups = "drop"
  ) %>%
  mutate(servicecodedescription = as_factor(servicecodedescription) %>% fct_reorder(avgpastdue)) %>%
  top_n(10) %>%
  ggplot(aes(avgpastdue, servicecodedescription, label = round(avgpastdue, digits = 0))) +
  geom_col(fill = col2) +
  coord_cartesian(clip = "off") +
  geom_text(
    hjust = 0,
    nudge_x = .3,
    size = 4.5
  ) +
  labs(
    title = glue("{percent_on_time} of DC Service Calls (311) have been resolved on time in 2022"),
    subtitle = glue("for those still Open or In-Progress, below is the average days past due by service requested"),
    caption = glue("Data source: https://opendata.dc.gov/ ({min_date_2022} to {max_date_2022})"),
    y = NULL,
    x = "Average days past due"
  ) +
  theme_classic() +
  theme(
    text = element_text(
      family = "montserrat",
      size = 16
    ),
    plot.title = element_markdown(
      family = "patua-one",
      size = 20,
      margin = margin(b = 5)
    ),
    plot.subtitle = element_markdown(margin = margin(b = 10)),
    plot.title.position = "plot",
    plot.caption.position = "plot",
    plot.caption = element_text(
      hjust = 0,
      margin = margin(t = 15)
    ),
    axis.line.y = element_blank(),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.ticks = element_blank(),
    axis.text = element_text(size = 14),
    # axis.line.x = element_line(),
    # axis.line.x.bottom = element_blank(),
    legend.position = "bottom",
    plot.margin = margin(t = 10, r = 20, b = 10, l = 20)
  )

dayspastdue

```

---

<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.